--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\.gitignore ---
bin
--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\.gitignore ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\Makefile ---
BINARY_NAME=getctx
BINARY_PATH=bin/$(BINARY_NAME)
MAIN_PACKAGE_PATH=./cmd/getctx

build:
	@go build -o $(BINARY_PATH) $(MAIN_PACKAGE_PATH)

run: build
	@$(BINARY_PATH)
--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\Makefile ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\README.md ---
# getctx

## In Progress

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\README.md ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\cmd\getctx\main.go ---
package main

import (
	"flag"
	"log"

	"getctx/internal/app"

	tea "github.com/charmbracelet/bubbletea"
)

func main() {
	// TODO: Move from the main.go
	outputFilename := flag.String("o", "context.txt", "The name of the output file")
	flag.Parse()

	startPath := "."
	if flag.NArg() > 0 {
		startPath = flag.Arg(0)
	}

	p := tea.NewProgram(app.NewModel(startPath))

	finalModel, err := p.Run()
	if err != nil {
		log.Fatalf("An error occurred while running the program: %v", err)
	}

	if m, ok := finalModel.(*app.Model); ok {
		if err := app.HandleContextBuilder(m, *outputFilename); err != nil {
			log.Fatalf("A critical error occurred while creating the context file: %v", err)
		}
	}
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\cmd\getctx\main.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\context.txt ---
--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\.gitignore ---
bin
--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\.gitignore ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\Makefile ---
BINARY_NAME=getctx
BINARY_PATH=bin/$(BINARY_NAME)
MAIN_PACKAGE_PATH=./cmd/getctx

build:
	@go build -o $(BINARY_PATH) $(MAIN_PACKAGE_PATH)

run: build
	@$(BINARY_PATH)
--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\Makefile ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\README.md ---
# getctx

## In Progress

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\README.md ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\cmd\getctx\main.go ---
package main

import (
	"flag"
	"log"

	"getctx/internal/app"

	tea "github.com/charmbracelet/bubbletea"
)

func main() {
	// TODO: Move from the main.go
	outputFilename := flag.String("o", "context.txt", "The name of the output file")
	flag.Parse()

	startPath := "."
	if flag.NArg() > 0 {
		startPath = flag.Arg(0)
	}

	p := tea.NewProgram(app.NewModel(startPath))

	finalModel, err := p.Run()
	if err != nil {
		log.Fatalf("An error occurred while running the program: %v", err)
	}

	if m, ok := finalModel.(*app.Model); ok {
		if err := app.HandleContextBuilder(m, *outputFilename); err != nil {
			log.Fatalf("A critical error occurred while creating the context file: %v", err)
		}
	}
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\cmd\getctx\main.go ---


--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\context.txt ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\docs\spec.md ---
# Technical Documentation / LLM Context: `getctx` Tool

## 1. Purpose and Core Functionality

`getctx` (Get Context) is a Command-Line Interface (CLI) tool written in Go. Its primary purpose is to allow a user to **interactively select files and folders** from the filesystem and then **concatenate the contents** of all selected (and eligible) text files into a single, large output file (defaults to `context.txt`).

The main use case is to quickly aggregate source code context from a project, which can then be pasted into AI tools (LLMs), bug reports, or documentation.

## 2. Project Architecture

The project is structured into several files, each with a clearly defined responsibility, following the **Separation of Concerns** principle:

- **`main.go`**: **Entrypoint**. It is responsible for:

  - Parsing command-line flags (e.g., `-o` for the output file).
  - Initializing and running the TUI.
  - Passing the results from the TUI to the context-building logic.
  - Handling top-level errors.

- **`tui.go`**: **Terminal User Interface (TUI)**.

  - All interactive logic resides here.
  - Built using the **`bubbletea`** library and the **Model-View-Update** architectural pattern.
  - **Model (`model` struct):** Holds the entire state of the interface: the current path, the list of files/folders, the cursor position, and a map of selected items.
  - **View (`View()` method):** Renders the model's state to the terminal screen, using styles from the `lipgloss` library.
  - **Update (`Update()` method):** Handles all user input (key presses) and modifies the model's state accordingly.

- **`context_builder.go`**: **Business Logic**.

  - Contains the "brain" of the application that runs after the TUI exits.
  - Responsible for processing the list of selected paths, filtering out binary files, and building the final `context.txt` file.
  - Prints detailed logs to the console about which files are being added and which are being skipped.

- **`fs_utils.go`**: **File System Utilities**.

  - A collection of general-purpose helper functions for file and folder operations.
  - **`discoverFiles`**: Recursively scans the given paths and returns a list of all found files, classified as either text or binary.
  - **`isTextFile`**: Detects if a given file is a text file (using a MIME type-based heuristic).

- **`ui.go`**: **UI Definitions**.

  - A central place for managing the application's look and feel.
  - Defines icons (emoji), colors, and complex styles (`lipgloss.Style`) used in both the TUI and the logs.
  - Styles are organized into nested structs (`TUIStyles`, `TUIListStyles`, `TUILogStyles`) for better readability and scalability.

- **`keybindings.go`**: **Keybinding Definitions**.
  - A central place that defines all keyboard shortcuts used in the application as constants (`const`).
  - Eliminates "magic strings" in the TUI logic and makes reconfiguring keys easy.

## 3. Key Features and Logic

- **Navigation:** The user navigates the filesystem using the up/down arrow keys. `Enter` opens a directory, and `Backspace` goes to the parent directory.
- **Selection:**
  - `Spacebar`: Toggles the selection for the individual file or folder under the cursor.
  - `CTRL+A`: Toggles the selection for all items in the current view.
- **Binary File Filtering:** The tool automatically detects and skips binary files (e.g., `.exe`, images, compiled artifacts), including only the content of text files in the final output. The user is informed about any skipped files.
- **Program Exit:**
  - `q`: Exits the interface and **initiates the build process** for the `context.txt` file from the selected items.
  - `CTRL+C`: **Cancels the operation**. Exits the program without saving the file.
- **Styling:** The application makes extensive use of the `lipgloss` library for styling (colors, bolding) in both the interactive TUI and the final log output, ensuring a consistent and modern look.

## 4. External Dependencies

- `github.com/charmbracelet/bubbletea`: The foundation of the TUI.
- `github.com/charmbracelet/lipgloss`: For styling text in the terminal.

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\docs\spec.md ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\go.mod ---
module getctx

go 1.25.0

require (
	github.com/charmbracelet/bubbletea v1.3.6
	github.com/charmbracelet/lipgloss v1.1.0
)

require (
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.9.3 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sync v0.15.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.3.8 // indirect
)

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\go.mod ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\go.sum ---
github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=
github.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=
github.com/charmbracelet/bubbletea v1.3.6 h1:VkHIxPJQeDt0aFJIsVxw8BQdh/F/L2KKZGsK6et5taU=
github.com/charmbracelet/bubbletea v1.3.6/go.mod h1:oQD9VCRQFF8KplacJLo28/jofOI2ToOfGYeFgBBxHOc=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc h1:4pZI35227imm7yK2bGPcfpFEmuY1gc2YSTShr4iJBfs=
github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc/go.mod h1:X4/0JoqgTIPSFcRA/P6INZzIuyqdFY5rm8tb41s9okk=
github.com/charmbracelet/lipgloss v1.1.0 h1:vYXsiLHVkK7fp74RkV7b2kq9+zDLoEU4MZoFqR/noCY=
github.com/charmbracelet/lipgloss v1.1.0/go.mod h1:/6Q8FR2o+kj8rz4Dq0zQc3vYf7X+B0binUUBwA0aL30=
github.com/charmbracelet/x/ansi v0.9.3 h1:BXt5DHS/MKF+LjuK4huWrC6NCvHtexww7dMayh6GXd0=
github.com/charmbracelet/x/ansi v0.9.3/go.mod h1:3RQDQ6lDnROptfpWuUVIUG64bD2g2BgntdxH0Ya5TeE=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd h1:vy0GVL4jeHEwG5YOXDmi86oYw2yuYUGqz6a8sLwg0X8=
github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd/go.mod h1:xe0nKWGd3eJgtqZRaN9RjMtK7xUYchjzPr7q6kcvCCs=
github.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=
github.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=
github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=
github.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=
github.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=
github.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=
github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=
github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=
github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=
github.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=
github.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=
github.com/muesli/termenv v0.16.0 h1:S5AlUN9dENB57rsbnkPyfdGuWIlkmzJjbFf0Tf5FWUc=
github.com/muesli/termenv v0.16.0/go.mod h1:ZRfOIKPFDYQoDFF4Olj7/QJbW60Ol/kL1pU3VfY/Cnk=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
golang.org/x/sync v0.15.0 h1:KWH3jNZsfyT6xfAfKiz6MRNmd46ByHDYaZ7KSkCtdW8=
golang.org/x/sync v0.15.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.3.8 h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\go.sum ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\config.go ---
package app

var ExcludedNames = map[string]struct{}{
	// Version control
	".git": {},
	".svn": {},
	".hg":  {},

	// Dependencies
	"node_modules": {},
	"vendor":       {},

	// IDE configuration
	".vscode": {},
	".idea":   {},

	// System files
	".DS_Store": {},
	"Thumbs.db": {},

	// Build artifacts & cache
	"bin":    {},
	"dist":   {},
	"build":  {},
	".cache": {},
	"target": {},
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\config.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\context_builder.go ---
package app

import (
	"fmt"
	"os"
	"sort"
)

func HandleContextBuilder(m *Model, outputFilename string) error {
	if len(m.selected) == 0 {
		fmt.Printf("%s No items selected. Exiting.\n", Icons.Error)
		return nil
	}

	selectedPaths := make([]string, 0, len(m.selected))
	for path := range m.selected {
		selectedPaths = append(selectedPaths, path)
	}

	return contextBuilder(selectedPaths, outputFilename)

}

func contextBuilder(selectedPaths []string, outputFilename string) error {

	acceptableFiles, err := discoverFiles(selectedPaths)
	if err != nil {
		return fmt.Errorf("error discovering files: %w", err)
	}

	var textFiles []string
	for _, path := range acceptableFiles {
		isText, _ := isTextFile(path)
		if isText {
			textFiles = append(textFiles, path)
		}
	}

	skippedFileCount := len(acceptableFiles) - len(textFiles)

	if len(textFiles) == 0 {
		message := fmt.Sprintf("\n%s No text files found to include.", Icons.Info)
		if skippedFileCount > 0 {
			message += fmt.Sprintf(" %d file(s) were skipped (non-text or unreadable).", skippedFileCount)
		}
		message += " Output file was not created."
		fmt.Println(message)
		return nil
	}

	fmt.Printf("%s Building context file: %s\n", Icons.Building, outputFilename)

	if skippedFileCount > 0 {
		fmt.Printf("   %s Skipped %d non-text or unreadable file(s).\n", Icons.Info, skippedFileCount)
	}

	sort.Strings(textFiles)
	for _, path := range textFiles {
		fmt.Printf("   %s Adding content from: %s\n", Icons.Cursor, path)
	}

	outputFile, err := os.Create(outputFilename)
	if err != nil {
		return fmt.Errorf("failed to create output file %s: %w", outputFilename, err)
	}
	defer outputFile.Close()

	for _, path := range textFiles {
		content, err := os.ReadFile(path)
		if err != nil {
			fmt.Printf("%s Warning: Failed to read file %s: %v\n", Icons.Warning, path, err)
			continue
		}
		header := fmt.Sprintf("--- START OF FILE: %s ---\n", path)
		footer := fmt.Sprintf("\n--- END OF FILE: %s ---\n\n", path)
		if _, err := outputFile.WriteString(header); err != nil {
			return fmt.Errorf("error writing header for file %s: %w", path, err)
		}
		if _, err := outputFile.Write(content); err != nil {
			return fmt.Errorf("error writing content for file %s: %w", path, err)
		}
		if _, err := outputFile.WriteString(footer); err != nil {
			return fmt.Errorf("error writing footer for file %s: %w", path, err)
		}
	}

	fmt.Printf("%s Done! All content has been combined into %s\n", Icons.Done, outputFilename)
	return nil
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\context_builder.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\fs_utils.go ---
package app

import (
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

func isExcluded(name string) bool {
	_, found := ExcludedNames[name]
	return found
}

func discoverFiles(paths []string) ([]string, error) {
	var discoveredPaths []string

	for _, path := range paths {
		if isExcluded(filepath.Base(path)) {
			continue
		}

		info, err := os.Stat(path)
		if err != nil {
			fmt.Printf("%s Warning: Could not stat path %s: %v\n", Icons.Warning, path, err)
			continue
		}

		if info.IsDir() {
			err := filepath.WalkDir(path, func(subPath string, d fs.DirEntry, err error) error {
				if err != nil {
					return err
				}

				if isExcluded(d.Name()) {
					if d.IsDir() {
						return filepath.SkipDir
					}
					return nil
				}

				if !d.IsDir() {
					discoveredPaths = append(discoveredPaths, subPath)
				}
				return nil
			})
			if err != nil {
				fmt.Printf("%s Warning: Error walking directory %s: %v\n", Icons.Warning, path, err)
			}
		} else {
			discoveredPaths = append(discoveredPaths, path)
		}
	}

	return discoveredPaths, nil
}

func isTextFile(path string) (bool, error) {
	file, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer file.Close()
	buffer := make([]byte, 512)
	n, err := file.Read(buffer)
	if err != nil && err != io.EOF {
		return false, err
	}
	contentType := http.DetectContentType(buffer[:n])
	return strings.HasPrefix(contentType, "text/"), nil
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\fs_utils.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\keybindings.go ---
package app

const (
	KeyCtrlC     = "ctrl+c"
	KeyQ         = "q"
	KeyUp        = "up"
	KeyDown      = "down"
	KeyEnter     = "enter"
	KeyBackspace = "backspace"
	KeySpace     = " "
	KeyCtrlA     = "ctrl+a"
)

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\keybindings.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\model.go ---
package app

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
)

type item struct {
	name       string
	isDir      bool
	isExcluded bool
}

type Model struct {
	path     string
	items    []item
	cursor   int
	selected map[string]struct{}
}

func NewModel(startPath string) *Model {
	path, err := filepath.Abs(startPath)
	if err != nil {
		log.Fatalf("Could not get absolute path for '%s': %v", startPath, err)
	}

	dirEntries, err := os.ReadDir(path)
	if err != nil {
		log.Fatalf("Could not read directory '%s': %v", path, err)
	}

	var items []item
	for _, entry := range dirEntries {
		items = append(items, item{name: entry.Name(), isDir: entry.IsDir(), isExcluded: isExcluded(entry.Name())})
	}

	return &Model{
		path:     path,
		items:    items,
		selected: make(map[string]struct{}),
	}
}

func (m *Model) Init() tea.Cmd {
	return nil
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		if len(m.items) == 0 && msg.String() != KeyQ && msg.String() != KeyCtrlC {
			return m, nil
		}

		currentItem := m.items[m.cursor]

		switch msg.String() {
		case KeyCtrlC:
			m.selected = make(map[string]struct{})
			return m, tea.Quit

		case KeyQ:
			return m, tea.Quit

		case KeyUp:
			if m.cursor > 0 {
				m.cursor--
			}

		case KeyDown:
			if m.cursor < len(m.items)-1 {
				m.cursor++
			}

		case KeyEnter:
			if currentItem.isDir && !currentItem.isExcluded {

				selectedItem := m.items[m.cursor]
				if selectedItem.isDir {
					newPath := filepath.Join(m.path, selectedItem.name)
					dirEntries, err := os.ReadDir(newPath)
					if err != nil {
						log.Printf("Error reading directory %s: %v", newPath, err)
						break
					}
					var newItems []item
					for _, entry := range dirEntries {
						newItems = append(newItems, item{name: entry.Name(), isDir: entry.IsDir()})
					}
					m.path = newPath
					m.items = newItems
					m.cursor = 0
				}
			}

		case KeyBackspace:
			parentPath := filepath.Dir(m.path)
			if parentPath != m.path {
				dirEntries, err := os.ReadDir(parentPath)
				if err != nil {
					log.Printf("Error reading directory %s: %v", parentPath, err)
					break
				}
				var newItems []item
				for _, entry := range dirEntries {
					newItems = append(newItems, item{name: entry.Name(), isDir: entry.IsDir()})
				}
				m.path = parentPath
				m.items = newItems
				m.cursor = 0
			}

		case KeySpace:
			if !currentItem.isExcluded {
				fullPath := filepath.Join(m.path, currentItem.name)
				if _, ok := m.selected[fullPath]; ok {
					delete(m.selected, fullPath)
				} else {
					m.selected[fullPath] = struct{}{}
				}
			}

		case KeyCtrlA:
			allSelectableAreSelected := true
			hasSelectableItems := false
			for _, item := range m.items {
				if !item.isExcluded {
					hasSelectableItems = true
					fullPath := filepath.Join(m.path, item.name)
					if _, ok := m.selected[fullPath]; !ok {
						allSelectableAreSelected = false
						break
					}
				}
			}

			if !hasSelectableItems {
				break
			}

			if allSelectableAreSelected {
				for _, item := range m.items {
					if !item.isExcluded {
						fullPath := filepath.Join(m.path, item.name)
						delete(m.selected, fullPath)
					}
				}
			} else {
				for _, item := range m.items {
					if !item.isExcluded {
						fullPath := filepath.Join(m.path, item.name)
						m.selected[fullPath] = struct{}{}
					}
				}
			}
		}
	}

	return m, nil
}

func (m *Model) View() string {
	var s strings.Builder
	s.WriteString("Select files for context (space: toggle, enter: open, backspace: up, q: save & quit)\n")
	s.WriteString("Current path: " + m.path + "\n\n")

	for i, item := range m.items {
		cursor := " "
		if m.cursor == i {
			cursor = Icons.Cursor
		}

		var prefix, itemIcon string

		if item.isExcluded {
			prefix = "  "
			itemIcon = Icons.Excluded
		} else {
			fullPath := filepath.Join(m.path, item.name)
			_, isSelected := m.selected[fullPath]

			if isSelected {
				prefix = Icons.Checkmark + " "
			} else {
				prefix = "  "
			}

			if item.isDir {
				itemIcon = Icons.Directory
			} else {
				itemIcon = Icons.File
			}
		}

		itemName := item.name
		if item.isDir {
			itemName += "/"
		}
		line := fmt.Sprintf("%s %s%s %s", cursor, prefix, itemIcon, itemName)

		fullPath := filepath.Join(m.path, item.name)
		_, isSelected := m.selected[fullPath]

		if item.isExcluded {
			s.WriteString(Styles.List.Excluded.Render(line))
		} else if isSelected {
			s.WriteString(Styles.List.Selected.Render(line))
		} else if m.cursor == i {
			s.WriteString(Styles.List.Cursor.Render(line))
		} else {
			s.WriteString(line)
		}
		s.WriteString("\n")
	}
	s.WriteString(fmt.Sprintf("\nSelected %d items. Press 'q' to save and exit.", len(m.selected)))
	return s.String()
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\model.go ---

--- START OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\theme.go ---
package app

import "github.com/charmbracelet/lipgloss"

const (
	colorGreen lipgloss.Color = "34"
	colorRed   lipgloss.Color = "9"
)

type TUIIcons struct {
	Building  string
	Done      string
	Warning   string
	Info      string
	Error     string
	Directory string
	File      string
	Checkmark string
	Cursor    string
	Excluded  string
}

type TUIColors struct {
	Green lipgloss.Color
	Red   lipgloss.Color
}

type TUIListStyles struct {
	Selected lipgloss.Style
	Cursor   lipgloss.Style
	Excluded lipgloss.Style
}

type TUILogStyles struct {
	Skipped lipgloss.Style
}

type TUIStyles struct {
	List TUIListStyles
	Log  TUILogStyles
}

var Icons TUIIcons
var Colors TUIColors
var Styles TUIStyles

func init() {
	Icons = TUIIcons{
		Building:  "🚀",
		Done:      "✅",
		Warning:   "⚠️",
		Info:      "ℹ️",
		Error:     "❌",
		Directory: "📁",
		File:      "📄",
		Checkmark: "✔",
		Cursor:    "❯",
		Excluded:  "🚫",
	}

	Colors = TUIColors{
		Green: colorGreen,
		Red:   colorRed,
	}

	Styles = TUIStyles{
		List: TUIListStyles{
			Selected: lipgloss.NewStyle().Foreground(Colors.Green),
			Cursor:   lipgloss.NewStyle().Bold(true),
			Excluded: lipgloss.NewStyle().Faint(true),
		},
		Log: TUILogStyles{
			Skipped: lipgloss.NewStyle().Foreground(Colors.Red),
		},
	}
}

--- END OF FILE: C:\Users\User\Programming\personal\getctx-go-testing\getctx-cli\internal\app\theme.go ---

